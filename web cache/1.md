# 根据存储位置分类

根据缓存存储的位置不同，可分为以下几种：

- Memory Cache
- Disk Cache
- Service Worker
- Push Cache

### Memory Cache

Memory Cache 就是存储在**内存**中的缓存，**读取速度快**，但是当关闭了 tab 页面，内存中的缓存就释放了，所以是一种临时的缓存，由于内存大小很珍贵，所以一般内存中适合存储**体积较小的内容**

当我们请求一个页面，并打开 F12-network 面板，可以看到某些资源的 Size 属性是`from memory cache`，那么该资源就是来自内存缓存

### Disk Cache

Disk Cache 是存储在硬盘中的缓存，它的读取速度会比 memory cache 慢一点，但是好处是硬盘缓存体积很大，可以存储比内存缓存更多的内容

当我们请求一个页面，并打开 F12-network 面板，可以看到某些资源的 Size 属性是`from disk cache`，那么该资源就是来自硬盘缓存

```
浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？
关于这点，网上说法不一，不过以下观点比较靠得住：
对于大文件来说，大概率是不存储在内存中的，反之优先
当前系统内存使用率高的话，文件优先存储进硬盘
```

### Service Worker（目前阶段不常用，未深入研究）

- Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能
- 传输协议必须为 HTTPS
- Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的

### Push Cache（目前阶段不常用，未深入研究）

- Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用
- 它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂

# 根据是否发起 http 请求分类

- 强缓存，不会向服务器发送请求，直接从缓存中读取资源
- 协商缓存，向服务器发送请求，决定是否使用缓存

### 强缓存

打开 F12-network 面板，可以看到该请求返回 200 的状态码，并且 Size 显示 `from disk cache` 或 `from memory cache`，那么这是一个强缓存请求

强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control`，这两种都表示概念“过期时间”，如果资源没有超过过期时间，那么就直接从缓存中拿出资源使用，而不去请求服务器

`Expires`是一个服务器的具体时间点，它是 http1.0 的产物，`Cache-Control`是 http1.1 的产物，两者同时存在的话，`Cache-Control` 优先级高于 `Expires`。在某些不支持 http1.1 的环境下，`Expires` 就会发挥用处。所以 `Expires` 其实是过时的产物，现阶段它的存在只是一种兼容性的写法

`Cache-Control`可以设置多种值

| Value        | Desc                                                                                |
| ------------ | ----------------------------------------------------------------------------------- |
| public       | 表示响应可以被客户端以及沿途的代理服务器缓存                                        |
| private      | 表示响应只能被客户端缓存                                                            |
| max-age=30   | 表示 缓存 30 秒后过期，需要重新请求（用于所有缓存）                                 |
| s-maxage=30  | 表示代理服务器的 缓存 30 秒后过期（仅用于沿途代理和网关的共享缓存），会覆盖 max-age |
| no-store     | 不缓存任何内容                                                                      |
| no-cache     | 内容被缓存，但是不使用缓存，会发送请求验证资源是否过期                              |
| max-stale=30 | 30 秒后即使缓存过期，也使用该缓存                                                   |
| :--------:   | -------------:                                                                      |

关于 no-cache 想多啰嗦两句，no-cache 是一个可以**确保内容最新**的手段，因为它每次都可以命中网络，**每次都会发起 http** 请求去询问服务器内容是否是最新，如果服务器没有更新内容，就返回 304 ，并且**只会传输文件报头**，文件主体可以从缓存中获取，而不必重新传输和下载；如果服务器有更新鲜的内容，它会返回 200 并且发送最新的文件

#### **must-revalidate**

```
Cache-Control: must-revalidate, max-age=600
```

如果说 no-cache 会立即向服务器验证，经过允许后才能使用缓存，那么 must-revalidate 更像是一个**具有宽期限**的 no-cache

must-revalidate 通常搭配 max-age 使用，如上述配置，表示在 600 秒内直接使用缓存，不请求服务器，当 600 秒过后，又去请求服务器，如果服务器没有更新，就返回 304，并且 600 秒重置重新开始，如果服务器更新了，就返回 200，本地缓存也会被更新

#### **immutable**

immutable 表示响应内容将一直不会改变，它和 max-age 是对缓存生命周期控制的互补性属性

如果没有超过时间上的过期失效时间，那么服务器端该页面内容将不会改变，这样浏览器就不应该再发送有条件的重新验证请求，比如通过 If-None-Match 或 If-Modified-Since 等条件再向服务器端发出更新检查，也就是说，通常过去我们使用 304 回复客户端该页面内容没有变化，但是如果用户按浏览器的刷新或 F5 键，浏览器会再次向服务器端发出该页面内容请求，服务器端如果确认该页面没有变化，那么发回 304 给客户端，不再发送该页面的实体内容，虽然这样节省了来回流量，但是如果大型网站的很多用户为了得到及时信息，经常会刷新浏览器，这就造成了大量刷新请求，向服务器端求证该页面是否改变，这会影响网站的带宽，也增加服务器端验证压力，而新的选项 immutable 可以杜绝这种现象

新的测试表明，immutable 可以节省数百个 HTTP 请求，这是因为服务器不必再处理 304 响应了

```
Cache-Control: max-age=31536000, immutable
```

### 协商缓存

浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，协商缓存可以通过设置两种 HTTP Header 实现：`Last-Modified` 和 `ETag`

#### **Last-Modified 和 If-Modified-Since**

服务器返回 Last-Modified ，指的是这个资源在服务器上的最后修改时间，浏览器请求资源得到这个 header 后，在下一次请求中会添加 If-Modified-Since 请求头，值就是上一回的 Last-Modified，服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 200

弊端：

1. 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源

2. 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

#### **ETag 和 If-None-Match**

Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成，通常是 md5 摘要等），只要资源有变化，Etag 就会重新生成

Etag 精度要优于 Last-Modified，优先级方面，服务器校验优先考虑 Etag

# Cache Busting（缓存破坏）

讲缓存而不讲**缓存破坏（Cache Busting）**是不负责任的，因为有一种情况是很常见并且棘手的，比如“我只是告诉过浏览器在接下来的一年使用这个文件（max-age），但后来我改动了它，我不想让用户拿到新副本之前要等一整年！我该怎么做？！”，我们在缓存之前一定要谨慎，因为一旦缓存在了用户的设备上，我们就失去了对他们的所有控制

#### **添加指纹**

添加指纹是目前破坏文件缓存的首选方法，是指在文件名中加入文件内容的 hash 摘要，（比如，文件名是 style.ae3f66.css，而不是 style.css），每次内容变更，文件名都会随之修改，这很稳健，并且允许你使用 `immutable`

如果你能够给你的静态资源可靠地做缓存破坏（使用指纹），那你最好一次性把所有的东西都缓存好几年，以求最优

```
Cache-Control: max-age=31536000, immutable
```

# 实践策略

1. 频繁变动的资源

   使用 `Cache-Control: no-cache`，使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小，并且保证文件内容的实时性

   缓存破坏极其极其极其重要。开始做缓存策略之前，先解决好缓存破坏策略。

2. 不常变化的资源

   配置一个很大的 `max-age=31536000` (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。为了解决更新问题，可以在文件名称中使用 hash、版本号等动态字符，从而达到更新 URL 的目的，让之前的强制缓存失效

3. 尽量不要缓存 html 入口文件

   一般来说，缓存 HTML 内容是个馊主意，毕竟 HTML 页往往是访问页面其他子资源的入口点，你会把通往静态文件的引用声明也缓存下来，会导致严重后果（你懂的）

# 实践

1. 包含交易清单、银行账户信息、当前余额和一些敏感的网站（比如银行），我们需要完全禁止缓存

```
Cache-Control: no-store

如果你觉得还不稳妥，可以这样
Cache-Control: private, no-cache, no-store
```

2. 实时股价、列车信息页面，我们需要时刻获取最新信息

```
Cache-Control: no-cache
```

3. FAQ 页面（没有具体业务逻辑就是一些说明性的页面），这种页面通常更新很少，也没有敏感信息，我们可以让它一周更新一次

```
Cache-Control: max-age=604800, must-revalidate
```

# 用户行为总结

- 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配，如有则使用；如没有则发送网络请求

- 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache

- 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache)，服务器直接返回 200 和最新内容
