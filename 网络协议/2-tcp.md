# DNS 协议

- 是一个应用层协议
- 是域名解析协议，域名 -> ip 地址

### 步骤

www.baidu.com(是一个二级域名，有几个.点就是几级域名)，从右往左解析

1. 域名被解析过了，读取缓存，直接返回 ip 地址，缓存可能是在本机器的本地（host 文件、dns 缓存文件），也可能在路由器（dns 缓存列表）

2. 没缓存，要向根 DNS 服务器发起 UDP 请求进行查询，依次递归查询.cn、.com.cn、.baidu.com.cn 的 IP

# TCP

- TCP 的数据格式，TCP 的头部最少是 20 字节，如果发送的数据非常小，只有 1 字节，那么每次传输也至少是 21 字节

- SYN 握手，ACK 确认，PSH 发消息，FIN 结束通信

### 握手挥手

- 三次握手

  1. 客户端 SYN 我要和你通信
  2. 服务端 ACK 同意 ，服务端 SYN 我也要和你通信
  3. 客户端 ACK 同意

- 四次挥手

  1. 客户端 FIN 断开通信 seq=160，ack=112

  2. 服务端 ACK 同意 ack=160+1（应答要在前者的询问的基础上 加 1 ，保证准确应答），seq=112（拿前者的 ack 作为自己的 seq）

  3. 如果还有未发送完的数据，发送完毕后，服务端 FIN 断开通信，ack=161，seq=112

  4. 客户端 ACK 同意，ack=112+1，seq=161（如果这个应答包丢失了，服务器没收到应答，服务器会重新发送 FIN 信号，直到客户端应答）

  5. TIME WAIT，是指客户端发送完最后的 ACK 后，不能立刻关闭，而是要等 1-2min，等服务端没有什么东西发过来了，再关闭，防止服务器没收到最后的 ACK 而再次发送 FIN 信号。如果等着，就会占用端口，会导致无法有新的连接进来，对于**高并发短链接**是不适合的。所以 http1.0 -> http1.1

<hr>

### 发送数据

**A 和 B 通信，各自都需要一个 sequence 序列号，来标识数据的顺序**

当客户端和服务器三次握手完成后，ack 和 seq 都是 1

客户端发送数据给服务端：ack=1，seq=1，len=5（数据长度）

服务端收到数据：ack=1+5=6，seq=1（长度是 5 的数据收到了，下次你要从 6 开始发，但是我没给你发数据，我的 seq 还是 1）

服务端给客户端发数据：seq=1，ack=6，len=2

客户端收到数据：ack=1+2=3，seq=6

# 额外知识补充

- 位（bit）是最小的存储单位，每一个位存储一个 1 位的二进制码
- 一个字节（byte）由 8 位组成

# UDP

面向报文的，不需要建立连接，速度快，只要数据发送出去就不管了，不保证数据完整性、安全性

```js
// node 中的 dgram模块 是用来创建 udp 连接的
let dgram = require('dgram')
let socket = dgram.createSocket('udp4')
socket.on('messgae'(msg, rinfo)=>{})
socket.bind(41234, 'localhost')
```
