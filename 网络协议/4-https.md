# https 保证密文，防止篡改

### 对称加密

双方有一把相同的钥匙，A 加密后发给 B，B 可以解密，但是中间人可以截获钥匙，篡改数据。**对称加密性能较高**

<hr>

### 非对称加密

服务端生成一对 公钥/私钥 ，给客户端一把公钥，客户端通过公钥加密数据，服务端用私钥解密。就算中间人截获了 公钥，也无法解密数据，因为解密需要私钥。但是，这样只能实现单向通信，服务端无法给客户端发数据

服务端生成一对 公钥 A/私钥 A ，客户端也生成一对 公钥 B/私钥 B，双方交换公钥，服务端用 公钥 B 加密数据给客户端，客户端用自己的 私钥 B 解密，即可实现双向加密通信。但是，**非对称加密性能差**

<hr>

### 混合加密

对称加密 + 非对称加密

1. 通过 非对称 解决 秘钥传输问题

   服务端生成一对 公钥/私钥，把公钥传给客户端；

   **这里存在问题：客户端并不知道得到的公钥是不是真的，有可能是中间人的**

   客户端生成一个随机数（会话秘钥），并用公钥加密，传给服务端；

   服务端用私钥解密，拿到会话秘钥那个随机数，两边就有了一把共同的钥匙，可以进行对称加密了

2. 通过 对称加密 进行数据传输

<hr>

### 数字证书和 CA（防止公钥被中间人篡改）

为了验证 公钥 的真伪，保证公钥是真正的服务器的公钥，需要一个官方来认证这个公钥

1. 服务端生成一对 公钥/私钥，把公钥传给 CA 进行认证

2. CA 拿到公钥生成一张数字证书，并对数字证书进行 hash 摘要（**因为证书内容太大，直接非对称加密，效率低**），摘要后使用 CA 自己的私钥进行加密，把加密证书、明文证书都传给客户端

3. 客户端的操作系统和浏览器都内置了 CA 公钥，拿 CA 公钥进行解密，得到证书的 hash 摘要（第一个），再对明文证书进行摘要得到一个 hash（第二个），对比第一个和第二个 hash 摘要，如果相同，那么明文证书可信，就拿出服务端公钥
